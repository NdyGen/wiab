/**
 * Comprehensive unit tests for RoomStateDevice class
 *
 * Tests cover:
 * - Device lifecycle (onInit, onSettings, onDeleted)
 * - State machine logic and transitions
 * - Error recovery and degraded mode
 * - WIAB device integration
 * - Manual override functionality
 * - Timer-based state management
 * - Capability management and repair
 * - Flow card integration
 */

import RoomStateDevice from '../drivers/wiab-room-state/device';
import { RoomStateEngine } from '../lib/RoomStateEngine';
import { WarningManager } from '../lib/WarningManager';
import { ErrorReporter } from '../lib/ErrorReporter';
import { RetryManager } from '../lib/RetryManager';
import { createMockHomey, createMockHomeyApi, createMockDevice } from './setup';
import { RoomStateErrorId } from '../constants/errorIds';

// Mock dependencies
jest.mock('../lib/RoomStateEngine');
jest.mock('../lib/WarningManager');
jest.mock('../lib/ErrorReporter');
jest.mock('../lib/RetryManager');

describe('RoomStateDevice', () => {
  let device: RoomStateDevice;
  let mockHomey: ReturnType<typeof createMockHomey>;
  let mockHomeyApi: ReturnType<typeof createMockHomeyApi>;
  let mockStateEngine: jest.Mocked<RoomStateEngine>;
  let mockWarningManager: jest.Mocked<WarningManager>;
  let mockErrorReporter: jest.Mocked<ErrorReporter>;
  let mockRetryManager: jest.Mocked<RetryManager>;
  let currentMockState: string;

  beforeEach(() => {
    jest.clearAllMocks();
    jest.useFakeTimers();

    // Setup mock Homey
    mockHomey = createMockHomey();
    mockHomeyApi = createMockHomeyApi();

    // Initialize stateful mock state
    currentMockState = 'idle';

    // Create mock instances with stateful behavior
    // The evaluateStateTransition mock needs to be smart about state transitions
    // to prevent infinite loops. By default, it should only suggest a transition
    // if the current state doesn't match the expected state for the zone activity.
    mockStateEngine = {
      getCurrentState: jest.fn(() => currentMockState),
      setCurrentState: jest.fn((newState: string) => { currentMockState = newState; }),
      evaluateStateTransition: jest.fn((currentState: string, isActive: boolean) => {
        // Default behavior: suggest occupied when active and idle, or idle when inactive and occupied
        if (isActive && currentState === 'idle') {
          return { nextState: 'occupied', reason: 'Zone became active', timerMinutes: 0 };
        } else if (!isActive && currentState === 'occupied') {
          return { nextState: 'idle', reason: 'Zone became inactive', timerMinutes: 0 };
        }
        // Already in correct state, no transition needed
        return { nextState: null, reason: '', timerMinutes: 0 };
      }),
      getNextTimedTransition: jest.fn().mockReturnValue(null),
      getAllStateIds: jest.fn().mockReturnValue(['idle', 'extended_idle', 'occupied', 'extended_occupied']),
      isState: jest.fn((current, target) => current === target),
      isExactlyState: jest.fn((current, target) => current === target),
      validateConfiguration: jest.fn().mockReturnValue({ valid: true, errors: [] }),
      getStateHierarchy: jest.fn().mockReturnValue(['idle']),
    } as unknown as jest.Mocked<RoomStateEngine>;

    mockWarningManager = {
      setWarning: jest.fn().mockResolvedValue(undefined),
      clearWarning: jest.fn().mockResolvedValue(undefined),
    } as unknown as jest.Mocked<WarningManager>;

    mockErrorReporter = {
      reportError: jest.fn(),
      getUserMessage: jest.fn().mockReturnValue('Test error message'),
    } as unknown as jest.Mocked<ErrorReporter>;

    mockRetryManager = {
      retryWithBackoff: jest.fn().mockImplementation(async (fn) => {
        try {
          await fn();
          return { success: true, attempts: 1, totalDurationMs: 100 };
        } catch (error) {
          return { success: false, attempts: 3, error, totalDurationMs: 500 };
        }
      }),
    } as unknown as jest.Mocked<RetryManager>;

    // Setup mock constructors
    (RoomStateEngine as jest.MockedClass<typeof RoomStateEngine>).mockImplementation(() => mockStateEngine);
    (WarningManager as jest.MockedClass<typeof WarningManager>).mockImplementation(() => mockWarningManager);
    (ErrorReporter as jest.MockedClass<typeof ErrorReporter>).mockImplementation(() => mockErrorReporter);
    (RetryManager as jest.MockedClass<typeof RetryManager>).mockImplementation(() => mockRetryManager);

    // Create device instance
    device = new RoomStateDevice();
    (device as any).homey = mockHomey;
    (device as any).homey.app = { homeyApi: mockHomeyApi };

    // Mock device methods
    device.log = jest.fn();
    device.error = jest.fn();
    device.getData = jest.fn().mockReturnValue({ id: 'room-state-123', zoneId: 'test-zone-123' });
    device.getSettings = jest.fn().mockReturnValue({
      wiabDeviceId: 'wiab-123',
      idleTimeout: 30,
      occupiedTimeout: 60,
    });
    device.setCapabilityValue = jest.fn().mockResolvedValue(undefined);
    device.hasCapability = jest.fn().mockReturnValue(true);
    device.addCapability = jest.fn().mockResolvedValue(undefined);
    device.removeCapability = jest.fn().mockResolvedValue(undefined);

    // Mock driver for flow card access
    const mockDriver = {
      homey: {
        flow: {
          getDeviceTriggerCard: jest.fn().mockReturnValue({
            trigger: jest.fn().mockResolvedValue(undefined),
          }),
        },
      },
    };
    Object.defineProperty(device, 'driver', {
      get: () => mockDriver,
      configurable: true,
    });
  });

  afterEach(() => {
    jest.useRealTimers();
    // Clear all timers to prevent accumulation
    jest.clearAllTimers();
    // Clear device map to prevent callback accumulation
    mockHomeyApi.devices._clear();
  });

  describe('onInit - Device Lifecycle', () => {
    it('should initialize successfully with valid configuration', async () => {
      // Arrange
      const mockWiabDevice = createMockDevice({
        id: 'wiab-123',
        name: 'Test WIAB',
        capabilities: ['alarm_occupancy'],
        capabilityValues: { alarm_occupancy: false },
      });
      mockHomeyApi.devices._addDevice('wiab-123', mockWiabDevice);

      // Act
      await device.onInit();

      // Assert
      expect(device.log).toHaveBeenCalledWith('Room State device initializing');
      expect(device.log).toHaveBeenCalledWith('Room State device initialized successfully');
      expect(WarningManager).toHaveBeenCalled();
      expect(ErrorReporter).toHaveBeenCalled();
      expect(RetryManager).toHaveBeenCalled();
      expect(RoomStateEngine).toHaveBeenCalled();
      expect(mockWarningManager.clearWarning).toHaveBeenCalled();
    });

    it('should initialize in occupied state when WIAB device is occupied', async () => {
      // Arrange
      const mockWiabDevice = createMockDevice({
        id: 'wiab-123',
        name: 'Test WIAB',
        capabilities: ['alarm_occupancy'],
        capabilityValues: { alarm_occupancy: true },
      });
      mockHomeyApi.devices._addDevice('wiab-123', mockWiabDevice);

      // Act
      await device.onInit();

      // Assert
      expect(device.log).toHaveBeenCalledWith(expect.stringContaining('starting in state: occupied'));
      expect(RoomStateEngine).toHaveBeenCalledWith(expect.anything(), 'occupied');
    });

    it('should handle initialization failure and enter degraded mode', async () => {
      // Arrange
      (device.getSettings as jest.Mock).mockReturnValue({
        wiabDeviceId: 'nonexistent-wiab',
        idleTimeout: 30,
        occupiedTimeout: 60,
      });

      // Act
      await device.onInit();

      // Assert
      expect(mockErrorReporter.reportError).toHaveBeenCalledWith(
        expect.objectContaining({
          errorId: RoomStateErrorId.DEVICE_INIT_FAILED,
        })
      );
      expect(mockWarningManager.setWarning).toHaveBeenCalledWith(
        RoomStateErrorId.DEVICE_INIT_FAILED,
        expect.any(String)
      );
      // Should not throw - device exists in degraded mode
    });

    it('should handle warning clear failure gracefully', async () => {
      // Arrange
      const mockWiabDevice = createMockDevice({
        id: 'wiab-123',
        name: 'Test WIAB',
        capabilities: ['alarm_occupancy'],
        capabilityValues: { alarm_occupancy: false },
      });
      mockHomeyApi.devices._addDevice('wiab-123', mockWiabDevice);

      mockWarningManager.clearWarning.mockRejectedValueOnce(new Error('Warning clear failed'));

      // Act
      await device.onInit();

      // Assert
      expect(device.log).toHaveBeenCalledWith('Room State device initialized successfully');
      expect(mockErrorReporter.reportError).toHaveBeenCalledWith(
        expect.objectContaining({
          errorId: RoomStateErrorId.WARNING_CLEAR_FAILED,
        })
      );
      // Should continue successfully despite warning clear failure
    });

    it('should handle WIAB device without makeCapabilityInstance', async () => {
      // Arrange
      const mockWiabDevice = createMockDevice({
        id: 'wiab-123',
        name: 'Test WIAB',
        capabilities: ['alarm_occupancy'],
        capabilityValues: { alarm_occupancy: false },
      });
      // Don't add makeCapabilityInstance
      mockWiabDevice.makeCapabilityInstance = undefined;
      mockHomeyApi.devices._addDevice('wiab-123', mockWiabDevice);

      // Act
      await device.onInit();

      // Assert
      expect(mockErrorReporter.reportError).toHaveBeenCalledWith(
        expect.objectContaining({
          errorId: RoomStateErrorId.DEVICE_INIT_FAILED,
        })
      );
    });

    it('should handle settings validation failure', async () => {
      // Arrange
      (device.getSettings as jest.Mock).mockReturnValue({
        wiabDeviceId: '',
        idleTimeout: -1,
        occupiedTimeout: -1,
      });

      // Act
      await device.onInit();

      // Assert
      expect(mockErrorReporter.reportError).toHaveBeenCalledWith(
        expect.objectContaining({
          errorId: expect.stringMatching(/SETTINGS_VALIDATION_FAILED|DEVICE_INIT_FAILED/),
        })
      );
    });
  });

  describe('onSettings - Settings Management', () => {
    beforeEach(async () => {
      // Initialize device first
      const mockWiabDevice = createMockDevice({
        id: 'wiab-123',
        name: 'Test WIAB',
        capabilities: ['alarm_occupancy'],
        capabilityValues: { alarm_occupancy: false },
      });
      mockHomeyApi.devices._addDevice('wiab-123', mockWiabDevice);
      await device.onInit();
      jest.clearAllMocks();
    });

    it('should reinitialize when wiabDeviceId changes', async () => {
      // Arrange
      const newWiabDevice = createMockDevice({
        id: 'wiab-456',
        name: 'New WIAB',
        capabilities: ['alarm_occupancy'],
        capabilityValues: { alarm_occupancy: false },
      });
      mockHomeyApi.devices._addDevice('wiab-456', newWiabDevice);

      (device.getSettings as jest.Mock).mockReturnValue({
        wiabDeviceId: 'wiab-456',
        idleTimeout: 30,
        occupiedTimeout: 60,
      });

      // Act
      await device.onSettings({
        oldSettings: { wiabDeviceId: 'wiab-123', idleTimeout: 30, occupiedTimeout: 60 },
        newSettings: { wiabDeviceId: 'wiab-456', idleTimeout: 30, occupiedTimeout: 60 },
        changedKeys: ['wiabDeviceId'],
      });

      // Assert
      expect(device.log).toHaveBeenCalledWith('Timer settings changed, reinitializing...');
      expect(RoomStateEngine).toHaveBeenCalled();
      expect(mockWarningManager.clearWarning).toHaveBeenCalled();
    });

    it('should reinitialize when timeout settings change', async () => {
      // Arrange
      const mockWiabDevice = createMockDevice({
        id: 'wiab-123',
        name: 'Test WIAB',
        capabilities: ['alarm_occupancy'],
        capabilityValues: { alarm_occupancy: false },
      });
      mockHomeyApi.devices._addDevice('wiab-123', mockWiabDevice);

      (device.getSettings as jest.Mock).mockReturnValue({
        wiabDeviceId: 'wiab-123',
        idleTimeout: 45,
        occupiedTimeout: 90,
      });

      // Act
      await device.onSettings({
        oldSettings: { wiabDeviceId: 'wiab-123', idleTimeout: 30, occupiedTimeout: 60 },
        newSettings: { wiabDeviceId: 'wiab-123', idleTimeout: 45, occupiedTimeout: 90 },
        changedKeys: ['idleTimeout', 'occupiedTimeout'],
      });

      // Assert
      expect(device.log).toHaveBeenCalledWith('Timer settings changed, reinitializing...');
      expect(RoomStateEngine).toHaveBeenCalled();
    });

    it('should not reinitialize for non-critical setting changes', async () => {
      // Act
      await device.onSettings({
        oldSettings: { wiabDeviceId: 'wiab-123', idleTimeout: 30, occupiedTimeout: 60 },
        newSettings: { wiabDeviceId: 'wiab-123', idleTimeout: 30, occupiedTimeout: 60 },
        changedKeys: ['someOtherSetting'],
      });

      // Assert
      expect(device.log).toHaveBeenCalledWith('Settings changed:', ['someOtherSetting']);
      expect(device.log).not.toHaveBeenCalledWith(expect.stringContaining('reinitializing'));
    });

    it('should handle settings update failure', async () => {
      // Arrange
      (device.getSettings as jest.Mock).mockReturnValue({
        wiabDeviceId: 'nonexistent',
        idleTimeout: 30,
        occupiedTimeout: 60,
      });

      // Act & Assert
      await expect(
        device.onSettings({
          oldSettings: { wiabDeviceId: 'wiab-123', idleTimeout: 30, occupiedTimeout: 60 },
          newSettings: { wiabDeviceId: 'nonexistent', idleTimeout: 30, occupiedTimeout: 60 },
          changedKeys: ['wiabDeviceId'],
        })
      ).rejects.toThrow();

      expect(mockErrorReporter.reportError).toHaveBeenCalledWith(
        expect.objectContaining({
          errorId: RoomStateErrorId.SETTINGS_UPDATE_FAILED,
        })
      );
      expect(mockWarningManager.setWarning).toHaveBeenCalled();
    });
  });

  describe('onDeleted - Cleanup', () => {
    it('should cleanup resources on delete', async () => {
      // Arrange
      const mockWiabDevice = createMockDevice({
        id: 'wiab-123',
        name: 'Test WIAB',
        capabilities: ['alarm_occupancy'],
        capabilityValues: { alarm_occupancy: false },
      });
      mockHomeyApi.devices._addDevice('wiab-123', mockWiabDevice);

      await device.onInit();

      // Act
      await device.onDeleted();

      // Assert
      expect(device.log).toHaveBeenCalledWith('Room State device being deleted');
      expect(device.log).toHaveBeenCalledWith('Room state management torn down');
    });

    it('should handle delete when not initialized', async () => {
      // Act
      await device.onDeleted();

      // Assert
      expect(device.log).toHaveBeenCalledWith('Room State device being deleted');
      // Should not throw
    });

    it('should handle teardown errors gracefully', async () => {
      // Arrange
      const mockWiabDevice = createMockDevice({
        id: 'wiab-123',
        name: 'Test WIAB',
        capabilities: ['alarm_occupancy'],
        capabilityValues: { alarm_occupancy: false },
      });
      mockHomeyApi.devices._addDevice('wiab-123', mockWiabDevice);
      await device.onInit();

      // Force an error during teardown by making log throw
      const originalLog = device.log;
      device.log = jest.fn().mockImplementation(() => {
        throw new Error('Log failed');
      });

      // Act
      await device.onDeleted();

      // Assert
      expect(mockErrorReporter.reportError).toHaveBeenCalledWith(
        expect.objectContaining({
          errorId: RoomStateErrorId.TEARDOWN_FAILED,
        })
      );
    });
  });

  describe('State Machine - Transitions', () => {
    beforeEach(async () => {
      const mockWiabDevice = createMockDevice({
        id: 'wiab-123',
        name: 'Test WIAB',
        capabilities: ['alarm_occupancy'],
        capabilityValues: { alarm_occupancy: false },
      });
      mockHomeyApi.devices._addDevice('wiab-123', mockWiabDevice);
      await device.onInit();
      jest.clearAllMocks();
    });

    it('should transition to occupied when WIAB device becomes occupied', async () => {
      // Arrange - the default smart mock should handle this correctly
      // No need to override evaluateStateTransition

      // Get the capability listener callback
      const wiabDevice = await mockHomeyApi.devices.getDevice('wiab-123');
      const callback = (wiabDevice as any)._capabilityCallbacks.get('alarm_occupancy');

      // Act
      callback(true);

      // Assert
      expect(device.log).toHaveBeenCalledWith('WIAB occupancy changed: OCCUPIED');
    });

    it('should transition to idle when WIAB device becomes unoccupied', async () => {
      // Arrange - first transition to occupied, then to idle
      currentMockState = 'occupied';

      const wiabDevice = await mockHomeyApi.devices.getDevice('wiab-123');
      const callback = (wiabDevice as any)._capabilityCallbacks.get('alarm_occupancy');

      // Act
      callback(false);

      // Assert
      expect(device.log).toHaveBeenCalledWith('WIAB occupancy changed: UNOCCUPIED');
    });

    it('should schedule timed transition when configured', async () => {
      // Arrange
      mockStateEngine.getNextTimedTransition.mockReturnValue({
        targetState: 'extended_idle',
        afterMinutes: 30,
      });

      const wiabDevice = await mockHomeyApi.devices.getDevice('wiab-123');
      const callback = (wiabDevice as any)._capabilityCallbacks.get('alarm_occupancy');

      // Act
      callback(false);
      jest.advanceTimersByTime(30 * 60 * 1000);

      // Assert
      expect(device.log).toHaveBeenCalledWith(
        expect.stringContaining('Scheduling transition to "extended_idle" in 30 minutes')
      );
    });

    it('should update capabilities on state transition', async () => {
      // Arrange - default mock behavior handles this
      const wiabDevice = await mockHomeyApi.devices.getDevice('wiab-123');
      const callback = (wiabDevice as any)._capabilityCallbacks.get('alarm_occupancy');

      // Act
      callback(true);
      await Promise.resolve();

      // Assert
      expect(device.setCapabilityValue).toHaveBeenCalledWith('room_state', 'occupied');
      expect(device.setCapabilityValue).toHaveBeenCalledWith('alarm_room_occupied', true);
    });

    it('should skip transition if already in target state', async () => {
      // Arrange - start in occupied state, then try to transition to occupied again
      currentMockState = 'occupied';

      const wiabDevice = await mockHomeyApi.devices.getDevice('wiab-123');
      const callback = (wiabDevice as any)._capabilityCallbacks.get('alarm_occupancy');

      // Act
      callback(true);

      // Assert
      // The smart mock returns null when already in correct state, so no transition happens
      // Check that the occupancy change was logged but no state transition occurred
      expect(device.log).toHaveBeenCalledWith('WIAB occupancy changed: OCCUPIED');
    });
  });

  describe('Manual Override', () => {
    beforeEach(async () => {
      const mockWiabDevice = createMockDevice({
        id: 'wiab-123',
        name: 'Test WIAB',
        capabilities: ['alarm_occupancy'],
        capabilityValues: { alarm_occupancy: false },
      });
      mockHomeyApi.devices._addDevice('wiab-123', mockWiabDevice);
      await device.onInit();
      jest.clearAllMocks();
    });

    it('should activate manual override and change state', async () => {
      // Arrange
      mockStateEngine.getAllStateIds.mockReturnValue(['idle', 'occupied', 'extended_occupied']);
      mockStateEngine.getCurrentState.mockReturnValue('idle');

      // Act
      await device.handleManualStateChange('occupied');

      // Assert
      expect(device.log).toHaveBeenCalledWith('Manual state change to: occupied');
      expect(mockStateEngine.setCurrentState).toHaveBeenCalledWith('occupied');
    });

    it('should ignore WIAB changes when manual override active', async () => {
      // Arrange
      await device.handleManualStateChange('occupied');
      jest.clearAllMocks();

      const wiabDevice = await mockHomeyApi.devices.getDevice('wiab-123');
      const callback = (wiabDevice as any)._capabilityCallbacks.get('alarm_occupancy');

      // Act
      callback(false);

      // Assert
      expect(device.log).toHaveBeenCalledWith('Manual override active - ignoring WIAB occupancy change');
    });

    it('should return to automatic mode', async () => {
      // Arrange
      await device.handleManualStateChange('occupied');
      jest.clearAllMocks();

      // Act
      await device.returnToAutomatic();

      // Assert
      expect(device.log).toHaveBeenCalledWith('Returning to automatic mode');
    });

    it('should reject invalid state ID in manual override', async () => {
      // Arrange
      mockStateEngine.getAllStateIds.mockReturnValue(['idle', 'occupied']);

      // Act
      await device.handleManualStateChange('invalid_state');

      // Assert
      expect(device.error).toHaveBeenCalledWith('Invalid state ID: invalid_state');
    });

    it('should handle error in manual state change', async () => {
      // Arrange
      mockStateEngine.getAllStateIds.mockReturnValue(['idle', 'occupied']);
      mockStateEngine.setCurrentState.mockImplementation(() => {
        throw new Error('State change failed');
      });

      // Act & Assert
      await expect(device.handleManualStateChange('occupied')).rejects.toThrow();

      expect(mockErrorReporter.reportError).toHaveBeenCalledWith(
        expect.objectContaining({
          errorId: RoomStateErrorId.STATE_TRANSITION_FAILED,
        })
      );
    });
  });

  describe('State Queries', () => {
    beforeEach(async () => {
      const mockWiabDevice = createMockDevice({
        id: 'wiab-123',
        name: 'Test WIAB',
        capabilities: ['alarm_occupancy'],
        capabilityValues: { alarm_occupancy: false },
      });
      mockHomeyApi.devices._addDevice('wiab-123', mockWiabDevice);
      await device.onInit();
      jest.clearAllMocks();
    });

    it('should check if in state with hierarchy support', () => {
      // Arrange
      mockStateEngine.getCurrentState.mockReturnValue('extended_occupied');
      mockStateEngine.isState.mockReturnValue(true);

      // Act
      const result = device.isInState('occupied');

      // Assert
      expect(result).toBe(true);
      expect(mockStateEngine.isState).toHaveBeenCalledWith('extended_occupied', 'occupied');
    });

    it('should check exact state match', () => {
      // Arrange
      mockStateEngine.getCurrentState.mockReturnValue('occupied');
      mockStateEngine.isExactlyState.mockImplementation((current, target) => current === target);

      // Act
      const result = device.isExactlyInState('occupied');

      // Assert
      expect(result).toBe(true);
    });

    it('should check manual override status', async () => {
      // Arrange & Act
      const beforeOverride = device.isManualOverride();
      await device.handleManualStateChange('occupied');
      const afterOverride = device.isManualOverride();
      await device.returnToAutomatic();
      const afterReturn = device.isManualOverride();

      // Assert
      expect(beforeOverride).toBe(false);
      expect(afterOverride).toBe(true);
      expect(afterReturn).toBe(false);
    });

    it('should return false for state queries when engine not initialized', () => {
      // Arrange
      const uninitializedDevice = new RoomStateDevice();
      (uninitializedDevice as any).homey = mockHomey;

      // Act
      const inState = uninitializedDevice.isInState('occupied');
      const exactlyInState = uninitializedDevice.isExactlyInState('occupied');

      // Assert
      expect(inState).toBe(false);
      expect(exactlyInState).toBe(false);
    });
  });

  describe('Capability Management', () => {
    beforeEach(async () => {
      const mockWiabDevice = createMockDevice({
        id: 'wiab-123',
        name: 'Test WIAB',
        capabilities: ['alarm_occupancy'],
        capabilityValues: { alarm_occupancy: false },
      });
      mockHomeyApi.devices._addDevice('wiab-123', mockWiabDevice);
    });

    it('should initialize capabilities with retry on success', async () => {
      // Act
      await device.onInit();

      // Assert
      expect(mockRetryManager.retryWithBackoff).toHaveBeenCalled();
      expect(device.setCapabilityValue).toHaveBeenCalledWith('room_state', 'idle');
      expect(device.setCapabilityValue).toHaveBeenCalledWith('alarm_room_occupied', false);
    });

    it('should add missing capability during initialization', async () => {
      // Arrange
      (device.hasCapability as jest.Mock).mockReturnValueOnce(false).mockReturnValue(true);

      // Act
      await device.onInit();

      // Assert
      expect(device.addCapability).toHaveBeenCalledWith('room_state');
    });

    it('should handle capability update failure with warning', async () => {
      // Arrange
      mockRetryManager.retryWithBackoff.mockResolvedValueOnce({
        success: false,
        attempts: 3,
        error: new Error('Capability failed'),
        totalDurationMs: 500,
      });

      // Act
      await device.onInit();

      // Assert
      expect(mockErrorReporter.reportError).toHaveBeenCalledWith(
        expect.objectContaining({
          errorId: RoomStateErrorId.CAPABILITY_UPDATE_FAILED,
        })
      );
      expect(mockWarningManager.setWarning).toHaveBeenCalled();
    });

    it('should repair missing capability during update', async () => {
      // Arrange
      await device.onInit();
      jest.clearAllMocks();

      (device.hasCapability as jest.Mock).mockReturnValueOnce(false).mockReturnValue(true);
      mockStateEngine.getCurrentState.mockReturnValue('idle');

      const wiabDevice = await mockHomeyApi.devices.getDevice('wiab-123');
      const callback = (wiabDevice as any)._capabilityCallbacks.get('alarm_occupancy');

      // Act
      callback(true);
      await Promise.resolve();

      // Assert
      expect(device.log).toHaveBeenCalledWith(expect.stringContaining('capability missing during update'));
      expect(mockRetryManager.retryWithBackoff).toHaveBeenCalled();
    });

    it('should compute occupancy indicator correctly', async () => {
      // Arrange
      await device.onInit();
      jest.clearAllMocks();

      const wiabDevice = await mockHomeyApi.devices.getDevice('wiab-123');
      const callback = (wiabDevice as any)._capabilityCallbacks.get('alarm_occupancy');

      // Act - transition to occupied
      callback(true);
      await Promise.resolve();

      // Assert
      expect(device.setCapabilityValue).toHaveBeenCalledWith('alarm_room_occupied', true);
    });

    it('should handle all capabilities failing', async () => {
      // Arrange
      (device.setCapabilityValue as jest.Mock).mockRejectedValue(new Error('All capabilities failed'));

      await device.onInit();
      jest.clearAllMocks();

      const wiabDevice = await mockHomeyApi.devices.getDevice('wiab-123');
      const callback = (wiabDevice as any)._capabilityCallbacks.get('alarm_occupancy');

      // Act & Assert
      await expect(async () => {
        callback(true);
        await Promise.resolve();
      }).rejects.toThrow();
    });
  });

  describe('Error Recovery', () => {
    it('should report WIAB device lookup failure', async () => {
      // Arrange
      (device.getSettings as jest.Mock).mockReturnValue({
        wiabDeviceId: 'nonexistent',
        idleTimeout: 30,
        occupiedTimeout: 60,
      });

      // Act
      await device.onInit();

      // Assert
      expect(mockErrorReporter.reportError).toHaveBeenCalledWith(
        expect.objectContaining({
          errorId: expect.stringMatching(/WIAB_DEVICE|DEVICE_INIT/),
        })
      );
    });

    it('should handle state transition errors gracefully', async () => {
      // Arrange
      const mockWiabDevice = createMockDevice({
        id: 'wiab-123',
        name: 'Test WIAB',
        capabilities: ['alarm_occupancy'],
        capabilityValues: { alarm_occupancy: false },
      });
      mockHomeyApi.devices._addDevice('wiab-123', mockWiabDevice);

      await device.onInit();

      mockStateEngine.evaluateStateTransition.mockImplementation(() => {
        throw new Error('Evaluation failed');
      });

      const wiabDevice = await mockHomeyApi.devices.getDevice('wiab-123');
      const callback = (wiabDevice as any)._capabilityCallbacks.get('alarm_occupancy');

      // Act
      callback(true);

      // Assert
      expect(mockErrorReporter.reportError).toHaveBeenCalledWith(
        expect.objectContaining({
          errorId: RoomStateErrorId.STATE_TRANSITION_FAILED,
        })
      );
    });

    it('should handle flow trigger failure', async () => {
      // Arrange
      const mockWiabDevice = createMockDevice({
        id: 'wiab-123',
        name: 'Test WIAB',
        capabilities: ['alarm_occupancy'],
        capabilityValues: { alarm_occupancy: false },
      });
      mockHomeyApi.devices._addDevice('wiab-123', mockWiabDevice);

      const mockTrigger = jest.fn().mockRejectedValue(new Error('Flow trigger failed'));
      const mockDriver = {
        homey: {
          flow: {
            getDeviceTriggerCard: jest.fn().mockReturnValue({
              trigger: mockTrigger,
            }),
          },
        },
      };
      Object.defineProperty(device, 'driver', {
        get: () => mockDriver,
        configurable: true,
      });

      await device.onInit();
      jest.clearAllMocks();

      const wiabDevice = await mockHomeyApi.devices.getDevice('wiab-123');
      const callback = (wiabDevice as any)._capabilityCallbacks.get('alarm_occupancy');

      // Act
      callback(true);
      await Promise.resolve();

      // Assert
      expect(mockErrorReporter.reportError).toHaveBeenCalledWith(
        expect.objectContaining({
          errorId: RoomStateErrorId.FLOW_TRIGGER_FAILED,
        })
      );
    });
  });

  describe('Timer Management', () => {
    beforeEach(async () => {
      const mockWiabDevice = createMockDevice({
        id: 'wiab-123',
        name: 'Test WIAB',
        capabilities: ['alarm_occupancy'],
        capabilityValues: { alarm_occupancy: false },
      });
      mockHomeyApi.devices._addDevice('wiab-123', mockWiabDevice);
      await device.onInit();
      jest.clearAllMocks();
    });

    it('should clear existing timer before scheduling new one', async () => {
      // Arrange
      mockStateEngine.getNextTimedTransition
        .mockReturnValueOnce({ targetState: 'extended_idle', afterMinutes: 30 })
        .mockReturnValueOnce({ targetState: 'occupied', afterMinutes: 0 });

      const wiabDevice = await mockHomeyApi.devices.getDevice('wiab-123');
      const callback = (wiabDevice as any)._capabilityCallbacks.get('alarm_occupancy');

      // Act
      callback(false);
      callback(true);

      // Assert
      expect(device.log).toHaveBeenCalledWith(expect.stringContaining('Scheduling transition'));
    });

    it('should execute timed transition after delay', async () => {
      // Arrange
      mockStateEngine.getNextTimedTransition.mockReturnValue({
        targetState: 'extended_idle',
        afterMinutes: 30,
      });

      const wiabDevice = await mockHomeyApi.devices.getDevice('wiab-123');
      const callback = (wiabDevice as any)._capabilityCallbacks.get('alarm_occupancy');

      // Act
      callback(false);
      jest.advanceTimersByTime(30 * 60 * 1000);

      // Assert
      expect(device.log).toHaveBeenCalledWith(expect.stringContaining('Timer fired'));
    });

    it('should handle timer scheduling error', async () => {
      // Arrange
      mockStateEngine.getNextTimedTransition.mockImplementation(() => {
        throw new Error('Timer error');
      });

      const wiabDevice = await mockHomeyApi.devices.getDevice('wiab-123');
      const callback = (wiabDevice as any)._capabilityCallbacks.get('alarm_occupancy');

      // Act
      callback(false);

      // Assert
      expect(mockErrorReporter.reportError).toHaveBeenCalledWith(
        expect.objectContaining({
          errorId: RoomStateErrorId.STATE_TRANSITION_FAILED,
        })
      );
    });
  });

  describe('State Configuration', () => {
    it('should build correct state configuration with both timeouts enabled', async () => {
      // Arrange
      (device.getSettings as jest.Mock).mockReturnValue({
        wiabDeviceId: 'wiab-123',
        idleTimeout: 30,
        occupiedTimeout: 60,
      });

      const mockWiabDevice = createMockDevice({
        id: 'wiab-123',
        name: 'Test WIAB',
        capabilities: ['alarm_occupancy'],
        capabilityValues: { alarm_occupancy: false },
      });
      mockHomeyApi.devices._addDevice('wiab-123', mockWiabDevice);

      // Act
      await device.onInit();

      // Assert
      const engineCall = (RoomStateEngine as jest.MockedClass<typeof RoomStateEngine>).mock.calls[0];
      const stateConfigs = engineCall[0];

      expect(stateConfigs).toHaveLength(4);
      expect(stateConfigs.find((s: any) => s.id === 'idle')).toBeDefined();
      expect(stateConfigs.find((s: any) => s.id === 'extended_idle')).toBeDefined();
      expect(stateConfigs.find((s: any) => s.id === 'occupied')).toBeDefined();
      expect(stateConfigs.find((s: any) => s.id === 'extended_occupied')).toBeDefined();
    });

    it('should disable extended idle when timeout is 0', async () => {
      // Arrange
      (device.getSettings as jest.Mock).mockReturnValue({
        wiabDeviceId: 'wiab-123',
        idleTimeout: 0,
        occupiedTimeout: 60,
      });

      const mockWiabDevice = createMockDevice({
        id: 'wiab-123',
        name: 'Test WIAB',
        capabilities: ['alarm_occupancy'],
        capabilityValues: { alarm_occupancy: false },
      });
      mockHomeyApi.devices._addDevice('wiab-123', mockWiabDevice);

      // Act
      await device.onInit();

      // Assert
      const engineCall = (RoomStateEngine as jest.MockedClass<typeof RoomStateEngine>).mock.calls[0];
      const stateConfigs = engineCall[0];
      const idleState = stateConfigs.find((s: any) => s.id === 'idle');

      expect(idleState).toBeDefined();
      expect(idleState!.inactiveTransitions).toHaveLength(0);
    });
  });
});
